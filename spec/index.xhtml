<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>streamCompare</h1>
      <dl>
        <dt>propagates the value returned by compare</dt>
        <dd><pre><code>const compareValue = false;
function compare(state1, state2) {
  return compareValue;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare)
  .then((value) =&#x3E; {
    assert.strictEqual(value, compareValue);
  });
stream1.end();
stream2.end();
return promise;</code></pre></dd>
        <dt>propagates the value thrown by compare</dt>
        <dd><pre><code>const compareErr = new Error(&#x27;compare error&#x27;);
function compare(state1, state2) {
  throw compareErr;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare).then(
  neverCalled,
  (err) =&#x3E; { assert.strictEqual(err, compareErr); },
);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
        <dt>propagates falsey value thrown by compare</dt>
        <dd><pre><code>const compareErr = false;
function compare(state1, state2) {
  throw compareErr;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare).then(
  neverCalled,
  (err) =&#x3E; { assert.strictEqual(err, compareErr); },
);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
        <dt>passes stream state information to compare</dt>
        <dd><pre><code>const data1 = Buffer.from(&#x27;hello&#x27;);
const data2 = Buffer.from(&#x27;there&#x27;);
function compare(state1, state2) {
  assert.deepStrictEqual(state1.data, data1);
  assert.deepStrictEqual(state1.ended, true);
  // PassThrough emits close after end in v14 (nodejs/node#30623)
  if (state1.events &#x26;&#x26; state1.events.length === 2) {
    assert.deepStrictEqual(state1.events, [
      { name: &#x27;close&#x27;, args: [] },
      { name: &#x27;end&#x27;, args: [] },
    ]);
  } else {
    assert.deepStrictEqual(state1.events, [
      { name: &#x27;close&#x27;, args: [] },
      { name: &#x27;end&#x27;, args: [] },
      { name: &#x27;close&#x27;, args: [] },
    ]);
  }
  assert.deepStrictEqual(state1.totalDataLen, data1.length);
  assert.deepStrictEqual(state2.data, data2);
  assert.deepStrictEqual(state2.ended, true);
  // PassThrough emits close after end in v14 (nodejs/node#30623)
  if (state2.events &#x26;&#x26; state2.events.length === 1) {
    assert.deepStrictEqual(state2.events, [
      { name: &#x27;end&#x27;, args: [] },
    ]);
  } else {
    assert.deepStrictEqual(state2.events, [
      { name: &#x27;end&#x27;, args: [] },
      { name: &#x27;close&#x27;, args: [] },
    ]);
  }
  assert.deepStrictEqual(state2.totalDataLen, data2.length);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
const writeSize = 2;
stream1.write(data1.slice(0, writeSize));
stream1.emit(&#x27;close&#x27;);
stream1.end(data1.slice(writeSize));
stream2.write(data2.slice(0, 0));
stream2.end(data2);
return promise;</code></pre></dd>
        <dt>treats string stream data as strings</dt>
        <dd><pre><code>const data1 = &#x27;hello&#x27;;
const data2 = &#x27;there&#x27;;
function compare(state1, state2) {
  assert.strictEqual(state1.data, data1);
  assert.strictEqual(state2.data, data2);
}
const stream1 = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const stream2 = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const promise = streamCompare(stream1, stream2, compare);
const writeSize = 2;
stream1.write(data1.slice(0, writeSize));
stream1.end(data1.slice(writeSize));
stream2.write(data2.slice(0, 0));
stream2.end(data2);
return promise;</code></pre></dd>
        <dt>compares empty streams as equal</dt>
        <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
        <dt>compares empty and non-empty streams as not equal</dt>
        <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
  );
stream1.end();
stream2.end(&#x27;hello&#x27;);
return promise;</code></pre></dd>
        <dt>compares non-empty and empty streams as not equal</dt>
        <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
  );
stream1.end(&#x27;hello&#x27;);
stream2.end();
return promise;</code></pre></dd>
        <dt>compares same-data streams as equal</dt>
        <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual);
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;hello&#x27;);
return promise;</code></pre></dd>
        <dt>compares different-data streams as not equal</dt>
        <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
  );
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;world&#x27;);
return promise;</code></pre></dd>
        <dt>compares buffered different-data streams as not equal</dt>
        <dd><pre><code>const compareVal = false;
function compare(state1, state2) {
  return compareVal;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;world&#x27;);
return new Promise((resolve, reject) =&#x3E; {
  process.nextTick(resolve);
}).then(() =&#x3E; streamCompare(stream1, stream2, compare)).then((result) =&#x3E; {
  assert.strictEqual(result, compareVal);
});</code></pre></dd>
        <dt>compares same-data same-writes as equal</dt>
        <dd><pre><code>// Note:  objectMode to prevent write-combining
const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual);
stream1.write(&#x27;hello&#x27;);
stream1.end(&#x27; world&#x27;);
stream2.write(&#x27;hello&#x27;);
stream2.end(&#x27; world&#x27;);
return promise;</code></pre></dd>
        <dt>compares same-data different-writes as equal</dt>
        <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual);
stream1.end(&#x27;hello world&#x27;);
stream2.write(&#x27;hello&#x27;);
stream2.end(&#x27; world&#x27;);
return promise;</code></pre></dd>
        <dt>compares different-writes to objectMode streams equal</dt>
        <dd><pre><code>const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual);
stream1.end(&#x27;hello world&#x27;);
stream2.write(&#x27;hello&#x27;);
stream2.end(&#x27; world&#x27;);
return promise;</code></pre></dd>
        <dt>compares different-writes as non-equal in objectMode</dt>
        <dd><pre><code>const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const options = {
  compare: assert.deepStrictEqual,
  objectMode: true,
};
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
);
stream1.end(&#x27;hello world&#x27;);
stream2.write(&#x27;hello&#x27;);
stream2.end(&#x27; world&#x27;);
return promise;</code></pre></dd>
        <section class="suite">
          <h1>argument checking</h1>
          <dl>
            <dt>throws for invalid stream1</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; {
    streamCompare(true, stream2, assert.deepStrictEqual);
  },
  (err) =&#x3E; err instanceof TypeError
      &#x26;&#x26; /\bstream1\b/.test(err.message),
);</code></pre></dd>
            <dt>throws for invalid stream2</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; {
    streamCompare(stream1, true, assert.deepStrictEqual);
  },
  (err) =&#x3E; err instanceof TypeError
      &#x26;&#x26; /\bstream2\b/.test(err.message),
);</code></pre></dd>
            <dt>throws for no .read() method and readPolicy &#x27;least&#x27;</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; {
    streamCompare(stream1, new EventEmitter(), assert.deepStrictEqual);
  },
  (err) =&#x3E; err instanceof TypeError
      &#x26;&#x26; /\bread\b/.test(err.message)
      &#x26;&#x26; /\bleast\b/.test(err.message),
);</code></pre></dd>
            <dt>throws for missing optionsOrCompare</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { streamCompare(stream1, stream2, null); },
  (err) =&#x3E; err instanceof TypeError
      &#x26;&#x26; /\boptions\.compare\b/.test(err.message),
);</code></pre></dd>
            <dt>throws for invalid optionsOrCompare</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; { streamCompare(stream1, stream2, true); },
  (err) =&#x3E; err instanceof TypeError
      &#x26;&#x26; /\boptions\.compare\b|\boptionsOrCompare\b/.test(err.message),
);</code></pre></dd>
            <dt>throws for invalid options.readPolicy</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; {
    const options = {
      compare: assert.deepStrictEqual,
      readPolicy: &#x27;invalid&#x27;,
    };
    streamCompare(stream1, stream2, options);
  },
  (err) =&#x3E; err instanceof RangeError
      &#x26;&#x26; /\boptions\.readPolicy\b/.test(err.message),
);</code></pre></dd>
            <dt>for invalid options.endEvents</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; {
    const options = {
      compare: assert.deepStrictEqual,
    };
    options[optionName] = true; // None accepts true as valid
    streamCompare(stream1, stream2, options);
  },
  (err) =&#x3E; {
    const optionRE = new RegExp(&#x60;\\boptions\\.${optionName}\\b&#x60;);
    return err instanceof TypeError
      &#x26;&#x26; optionRE.test(err.message);
  },
);</code></pre></dd>
            <dt>for invalid options.events</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; {
    const options = {
      compare: assert.deepStrictEqual,
    };
    options[optionName] = true; // None accepts true as valid
    streamCompare(stream1, stream2, options);
  },
  (err) =&#x3E; {
    const optionRE = new RegExp(&#x60;\\boptions\\.${optionName}\\b&#x60;);
    return err instanceof TypeError
      &#x26;&#x26; optionRE.test(err.message);
  },
);</code></pre></dd>
            <dt>for invalid options.incremental</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; {
    const options = {
      compare: assert.deepStrictEqual,
    };
    options[optionName] = true; // None accepts true as valid
    streamCompare(stream1, stream2, options);
  },
  (err) =&#x3E; {
    const optionRE = new RegExp(&#x60;\\boptions\\.${optionName}\\b&#x60;);
    return err instanceof TypeError
      &#x26;&#x26; optionRE.test(err.message);
  },
);</code></pre></dd>
            <dt>for invalid options.readPolicy</dt>
            <dd><pre><code>assert.throws(
  () =&#x3E; {
    const options = {
      compare: assert.deepStrictEqual,
    };
    options[optionName] = true; // None accepts true as valid
    streamCompare(stream1, stream2, options);
  },
  (err) =&#x3E; {
    const optionRE = new RegExp(&#x60;\\boptions\\.${optionName}\\b&#x60;);
    return err instanceof TypeError
      &#x26;&#x26; optionRE.test(err.message);
  },
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>abortOnError</h1>
          <dl>
            <dt>compares error events by default</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual);
stream1.emit(&#x27;error&#x27;, new Error(&#x27;Test&#x27;));
stream2.emit(&#x27;error&#x27;, new Error(&#x27;Test&#x27;));
return promise;</code></pre></dd>
            <dt>can abort on error events</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  abortOnError: true,
  compare: assert.deepStrictEqual,
};
const errTest = new Error(&#x27;Test&#x27;);
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
  },
);
stream1.emit(&#x27;error&#x27;, errTest);
return promise;</code></pre></dd>
            <dt>doesn&#x27;t call incremental or compare on abort</dt>
            <dd><pre><code>function compare(state1, state2) {
  process.nextTick(() =&#x3E; {
    throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
  });
}
function incremental(state1, state2) {
  process.nextTick(() =&#x3E; {
    throw new Error(&#x27;incremental shouldn\&#x27;t be called&#x27;);
  });
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  abortOnError: true,
  compare,
  incremental,
};
const errTest = new Error(&#x27;Test&#x27;);
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
  },
);
stream1.emit(&#x27;error&#x27;, errTest);
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>delay</h1>
          <dl>
            <dt>compares delayed end events if delayed more</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
// Since 0 is treated as 1, min is 1
const eventDelay = 1;
const options = {
  compare: assert.deepStrictEqual,
  delay: eventDelay + 1,
};
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
);
stream1.end();
stream2.end();
setTimeout(() =&#x3E; {
  stream1.emit(&#x27;end&#x27;);
}, eventDelay);
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>endEvents</h1>
          <dl>
            <dt>can end on custom event</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare: assert.deepStrictEqual,
  endEvents: [&#x27;test&#x27;],
};
let ended = false;
const promise = streamCompare(stream1, stream2, options)
  .then(() =&#x3E; { ended = true; });
stream1.emit(&#x27;test&#x27;);
return new Promise((resolve, reject) =&#x3E; {
  setImmediate(() =&#x3E; {
    assert.strictEqual(ended, false);
    stream2.emit(&#x27;test&#x27;);
    resolve(promise);
  });
});</code></pre></dd>
            <dt>can avoid ending on stream &#x27;end&#x27;</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
let ended = false;
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(() =&#x3E; { ended = true; });
stream1.end();
stream2.end();
return new Promise((resolve, reject) =&#x3E; {
  setImmediate(() =&#x3E; {
    assert.strictEqual(ended, false);
    resolve(promise);
  });
});</code></pre></dd>
            <dt>abortOnError takes precedence for &#x27;error&#x27; event</dt>
            <dd><pre><code>function compare(state1, state2) {
  process.nextTick(() =&#x3E; {
    throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
  });
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  abortOnError: true,
  compare,
  endEvents: [&#x27;end&#x27;, &#x27;error&#x27;],
};
const errTest = new Error(&#x27;Test&#x27;);
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; {
    assert.strictEqual(err, errTest);
  },
);
// Note:  .emit() rather than .end() to avoid delay
stream1.emit(&#x27;end&#x27;);
stream2.emit(&#x27;error&#x27;, errTest);
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>events</h1>
          <dl>
            <dt>compares Readable events by default</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual);
stream1.emit(&#x27;close&#x27;);
stream1.end();
stream2.emit(&#x27;close&#x27;);
stream2.end();
return promise;</code></pre></dd>
            <dt>compares events immediately after end by default</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.deepStrictEqual(state1, state2);
  assert.deepStrictEqual(
    state1.events[state1.events.length - 1].name,
    &#x27;close&#x27;,
  );
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
function emitClose() { this.emit(&#x27;close&#x27;); }
stream1.once(&#x27;end&#x27;, emitClose);
stream2.once(&#x27;end&#x27;, emitClose);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>can ignore all events</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.deepStrictEqual(state1.events, []);
  assert.deepStrictEqual(state2.events, []);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  events: [],
};
const promise = streamCompare(stream1, stream2, options);
stream1.emit(&#x27;close&#x27;);
stream1.emit(&#x27;error&#x27;);
stream1.end();
stream2.emit(&#x27;close&#x27;);
stream2.emit(&#x27;error&#x27;);
stream2.end();
return promise;</code></pre></dd>
            <dt>ignores non-Readable events by default</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual);
stream1.end();
stream1.emit(&#x27;finish&#x27;);
stream2.end();
return promise;</code></pre></dd>
            <dt>can compare custom events</dt>
            <dd><pre><code>const eventValue = {};
function compare(state1, state2) {
  assert.deepStrictEqual(state1.events, [
    { name: &#x27;test&#x27;, args: [eventValue] },
  ]);
  assert.deepStrictEqual(state2.events, []);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  events: [&#x27;test&#x27;],
};
const promise = streamCompare(stream1, stream2, options);
stream1.emit(&#x27;test&#x27;, eventValue);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>ignores multiple occurrances of event name</dt>
            <dd><pre><code>const eventValue = {};
function compare(state1, state2) {
  assert.deepStrictEqual(state1.events, [
    { name: &#x27;test&#x27;, args: [eventValue] },
  ]);
  assert.deepStrictEqual(state2.events, []);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  events: [&#x27;test&#x27;, &#x27;test&#x27;],
};
const promise = streamCompare(stream1, stream2, options);
stream1.emit(&#x27;test&#x27;, eventValue);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>compares different Readable events as different</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
  );
stream1.emit(&#x27;close&#x27;);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>compares different event counts as different</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
  );
stream1.emit(&#x27;close&#x27;);
stream1.emit(&#x27;close&#x27;);
stream1.end();
stream2.emit(&#x27;close&#x27;);
stream2.end();
return promise;</code></pre></dd>
            <dt>compares multiple non-overlapping end events</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
  );
// streamCompare may read from either stream first and the &#x27;end&#x27; event
// does not fire until read() is called after EOF, so we emit directly
// for first stream.  Then streamCompare must read from the second.
stream1.emit(&#x27;end&#x27;);
process.nextTick(() =&#x3E; {
  stream1.emit(&#x27;end&#x27;);
  stream2.end();
});
return promise;</code></pre></dd>
            <dt>compares immediate overlapping end events</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
  );
stream1.end();
stream2.end();
stream2.once(&#x27;end&#x27;, () =&#x3E; {
  process.nextTick(() =&#x3E; {
    stream1.emit(&#x27;end&#x27;);
  });
});
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>incremental</h1>
          <dl>
            <dt>has no effect if null is returned</dt>
            <dd><pre><code>function incremental(state1, state2) {
  return null;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare: assert.deepStrictEqual,
  incremental,
};
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
);
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;world&#x27;);
return promise;</code></pre></dd>
            <dt>avoids compare if a non-null value is returned</dt>
            <dd><pre><code>const incrementalValue = false;
function compare(state1, state2) {
  throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
}
function incremental(state1, state2) {
  return incrementalValue;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  incremental,
};
const promise = streamCompare(stream1, stream2, options)
  .then((value) =&#x3E; {
    assert.strictEqual(value, incrementalValue);
  });
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;hello&#x27;);
return promise;</code></pre></dd>
            <dt>avoids compare if a value is thrown</dt>
            <dd><pre><code>const incrementalErr = new Error(&#x27;incremental error&#x27;);
function compare(state1, state2) {
  throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
}
function incremental(state1, state2) {
  throw incrementalErr;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  incremental,
};
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; { assert.strictEqual(err, incrementalErr); },
);
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;hello&#x27;);
return promise;</code></pre></dd>
            <dt>causes early return if a value is thrown</dt>
            <dd><pre><code>const incrementalErr = new Error(&#x27;incremental error&#x27;);
function compare(state1, state2) {
  throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
}
function incremental(state1, state2) {
  throw incrementalErr;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  incremental,
};
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; { assert.strictEqual(err, incrementalErr); },
);
stream1.end(&#x27;hello&#x27;);
// stream2 writes more than stream1 but does not end.
stream2.write(&#x27;hello2&#x27;);
return promise;</code></pre></dd>
            <dt>is used in place of compare, if not specified</dt>
            <dd><pre><code>const incrementalValue = false;
function incremental(state1, state2) {
  return state1.ended &#x26;&#x26; state2.ended ? incrementalValue : null;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  incremental,
};
const promise = streamCompare(stream1, stream2, options)
  .then((value) =&#x3E; {
    assert.strictEqual(value, incrementalValue);
  });
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;world&#x27;);
return promise;</code></pre></dd>
            <dt>calls done once when conclusive on end</dt>
            <dd><pre><code>function compare(state1, state2) {
  throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
}
const incrementalValue = {};
function incremental(state1, state2) {
  return incrementalValue;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  incremental,
};
const promise = streamCompare(stream1, stream2, options)
  .then((value) =&#x3E; {
    assert.strictEqual(value, incrementalValue);
  });
stream1.end();
stream2.end();
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>objectMode</h1>
          <dl>
            <dt>errors on differing-type reads not in objectMode</dt>
            <dd><pre><code>// Streams are in objectMode, streamCompare is not
const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, TypeError); },
  );
stream1.write(&#x27;hello&#x27;);
stream1.end(Buffer.from(&#x27; world&#x27;));
stream2.end();
return promise;</code></pre></dd>
            <dt>errors on object reads not in objectMode</dt>
            <dd><pre><code>// Streams are in objectMode, streamCompare is not
const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const promise = streamCompare(stream1, stream2, assert.deepStrictEqual)
  .then(
    neverCalled,
    (err) =&#x3E; { assertInstanceOf(err, TypeError); },
  );
stream1.end({ test: true });
stream2.end();
return promise;</code></pre></dd>
            <dt>supports object reads in objectMode</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const options = {
  compare: assert.deepStrictEqual,
  objectMode: true,
};
const promise = streamCompare(stream1, stream2, options);
stream1.end({ test: true });
stream2.end({ test: true });
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>readPolicy</h1>
          <dl>
            <dt>doesn&#x27;t call read() when &#x27;flowing&#x27;</dt>
            <dd><pre><code>let isDone = false;
let isPaused = true;
function incremental(state1, state2) {
  assert.strictEqual(isPaused, false);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare: assert.deepStrictEqual,
  readPolicy: &#x27;flowing&#x27;,
  incremental,
};
const promise = streamCompare(stream1, stream1, options).then(() =&#x3E; {
  isDone = true;
});
stream1.pause();
stream1.write(&#x27;hello&#x27;);
stream2.pause();
stream2.write(&#x27;hello&#x27;);
// Delay to ensure we don&#x27;t read/finish
setImmediate(() =&#x3E; {
  assert.strictEqual(isDone, false);
  isPaused = false;
  stream1.resume();
  stream2.resume();
  stream1.end();
  stream2.end();
});
return promise;</code></pre></dd>
            <dt>compares the same stream as equal when &#x27;flowing&#x27;</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const options = {
  compare: assert.deepStrictEqual,
  readPolicy: &#x27;flowing&#x27;,
};
const promise = streamCompare(stream1, stream1, options);
stream1.end(&#x27;hello&#x27;);
return promise;</code></pre></dd>
            <dt>handles empty-Buffer &#x27;read&#x27; events</dt>
            <dd><pre><code>const data1 = Buffer.from(&#x27;hello world&#x27;);
const data2 = [
  Buffer.from(&#x27;hello&#x27;),
  Buffer.alloc(0),
  Buffer.from(&#x27; world&#x27;),
];
function compare(state1, state2) {
  assert.deepStrictEqual(state1.data, data1);
  assert.deepStrictEqual(state1.events, [
    { name: &#x27;data&#x27;, args: [data1] },
  ]);
  // Data properly recombined by flowing reads
  assert.deepStrictEqual(state2.data, Buffer.concat(data2));
  // Events record each &#x27;data&#x27; event, even empty ones
  assert.deepStrictEqual(state2.events, [
    { name: &#x27;data&#x27;, args: [data2[0]] },
    { name: &#x27;data&#x27;, args: [data2[1]] },
    { name: &#x27;data&#x27;, args: [data2[2]] },
  ]);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  events: [&#x27;data&#x27;],
  readPolicy: &#x27;flowing&#x27;,
};
const promise = streamCompare(stream1, stream2, options);
stream1.end(data1);
stream2.write(data2[0]);
// stream.PassThrough suppresses empty writes.  Emit it ourselves.
stream2.emit(&#x27;data&#x27;, data2[1]);
stream2.end(data2[2]);
return promise;</code></pre></dd>
            <dt>handles empty-string &#x27;read&#x27; events</dt>
            <dd><pre><code>const data1 = &#x27;hello world&#x27;;
const data2 = [&#x27;hello&#x27;, &#x27;&#x27;, &#x27; world&#x27;];
function compare(state1, state2) {
  assert.deepStrictEqual(state1.data, data1);
  assert.deepStrictEqual(state1.events, [
    { name: &#x27;data&#x27;, args: [data1] },
  ]);
  // Data properly recombined by flowing reads
  assert.deepStrictEqual(state2.data, data2.join(&#x27;&#x27;));
  // Events record each &#x27;data&#x27; event, even empty ones
  assert.deepStrictEqual(state2.events, [
    { name: &#x27;data&#x27;, args: [data2[0]] },
    { name: &#x27;data&#x27;, args: [data2[1]] },
    { name: &#x27;data&#x27;, args: [data2[2]] },
  ]);
}
const stream1 = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const stream2 = new stream.PassThrough({ encoding: &#x27;utf8&#x27; });
const options = {
  compare,
  events: [&#x27;data&#x27;],
  readPolicy: &#x27;flowing&#x27;,
};
const promise = streamCompare(stream1, stream2, options);
stream1.end(data1);
stream2.write(data2[0]);
// stream.PassThrough suppresses empty writes.  Emit it ourselves.
stream2.emit(&#x27;data&#x27;, data2[1]);
stream2.end(data2[2]);
return promise;</code></pre></dd>
            <dt>doesn&#x27;t read any data when &#x27;none&#x27;</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.strictEqual(state1.data, undefined);
  assert.strictEqual(state2.data, undefined);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  readPolicy: &#x27;none&#x27;,
};
const promise = streamCompare(stream1, stream2, options);
// Since there are no &#x27;data&#x27; listeners, must .resume() to get &#x27;end&#x27;
stream1.resume();
stream2.resume();
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;world&#x27;);
return promise;</code></pre></dd>
            <dt>can treat data as events only</dt>
            <dd><pre><code>const data1 = Buffer.from(&#x27;hello&#x27;);
const data2 = Buffer.from(&#x27;world&#x27;);
function compare(state1, state2) {
  assert.strictEqual(state1.data, undefined);
  assert.strictEqual(state2.data, undefined);
  // PassThrough emits close after end in v14 (nodejs/node#30623)
  if (state1.events &#x26;&#x26; state1.events.length === 3) {
    assert.deepStrictEqual(state1.events, [
      { name: &#x27;close&#x27;, args: [] },
      { name: &#x27;data&#x27;, args: [data1] },
      { name: &#x27;end&#x27;, args: [] },
    ]);
  } else {
    assert.deepStrictEqual(state1.events, [
      { name: &#x27;close&#x27;, args: [] },
      { name: &#x27;data&#x27;, args: [data1] },
      { name: &#x27;end&#x27;, args: [] },
      { name: &#x27;close&#x27;, args: [] },
    ]);
  }
  if (state2.events &#x26;&#x26; state2.events.length === 3) {
    assert.deepStrictEqual(state2.events, [
      { name: &#x27;data&#x27;, args: [data2] },
      { name: &#x27;close&#x27;, args: [] },
      { name: &#x27;end&#x27;, args: [] },
    ]);
  } else {
    assert.deepStrictEqual(state2.events, [
      { name: &#x27;data&#x27;, args: [data2] },
      { name: &#x27;close&#x27;, args: [] },
      { name: &#x27;end&#x27;, args: [] },
      { name: &#x27;close&#x27;, args: [] },
    ]);
  }
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  events: [&#x27;close&#x27;, &#x27;data&#x27;, &#x27;end&#x27;, &#x27;error&#x27;],
  readPolicy: &#x27;none&#x27;,
};
const promise = streamCompare(stream1, stream2, options);
stream1.emit(&#x27;close&#x27;);
stream1.end(data1);
stream2.write(data2);
stream2.emit(&#x27;close&#x27;);
stream2.end();
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.makeIncremental()</h1>
          <dl>
            <dt>makes incremental from a Buffer comparison function</dt>
            <dd><pre><code>const data1 = [Buffer.from(&#x27;hello&#x27;), Buffer.from(&#x27;world&#x27;)];
const data2 = [Buffer.from(&#x27;hello&#x27;), Buffer.from(&#x27;there&#x27;)];
// Use of compareCount in this way is illustrative, but over-specified.
// Callers shouldn&#x27;t depend on this exact behavior.
// If this test breaks, it may be rewritten in a less-strict way
let compareCount = 0;
const compareValue = false;
function compareData(incData1, incData2) {
  assert.deepStrictEqual(incData1, data1[compareCount]);
  assert.deepStrictEqual(incData2, data2[compareCount]);
  compareCount += 1;
  // null/undefined means &#x22;continue comparing future data&#x22;
  return incData1.equals(incData2) ? null : compareValue;
}
function compare(state1, state2) {
  throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
}
// Note:  objectMode to prevent write-combining
const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const options = {
  compare,
  incremental: streamCompare.makeIncremental(compareData),
};
const promise = streamCompare(stream1, stream2, options)
  .then((value) =&#x3E; {
    assert.strictEqual(value, compareValue);
  });
stream1.write(data1[0]);
stream2.write(data2[0]);
stream1.end(data1[1]);
stream2.end(data2[1]);
return promise;</code></pre></dd>
            <dt>makes incremental from an event comparison function</dt>
            <dd><pre><code>const compareValue = false;
function compareEvents(incEvents1, incEvents2) {
  assertInstanceOf(incEvents1, Array);
  assertInstanceOf(incEvents2, Array);
  try {
    assert.assert.deepStrictEqual(incEvents1, incEvents2);
    // null/undefined means &#x22;continue comparing future data&#x22;
    return null;
  } catch (err) {
    return compareValue;
  }
}
function compare(state1, state2) {
  throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  incremental: streamCompare.makeIncremental(null, compareEvents),
};
const promise = streamCompare(stream1, stream2, options)
  .then((value) =&#x3E; {
    assert.strictEqual(value, compareValue);
  });
stream1.emit(&#x27;close&#x27;);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>removes inconclusive data before compare</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.strictEqual(state1.data.length, 0);
  assert.strictEqual(state2.data.length, 0);
}
// Note:  objectMode to prevent write-combining
const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const options = {
  compare,
  incremental: streamCompare.makeIncremental(assert.deepStrictEqual),
};
const promise = streamCompare(stream1, stream2, options);
stream1.write(&#x27;hello&#x27;);
stream1.end(&#x27; world&#x27;);
stream2.write(&#x27;hello&#x27;);
stream2.end(&#x27; world&#x27;);
return promise;</code></pre></dd>
            <dt>removes inconclusive string data before compare</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.strictEqual(state1.data.length, 0);
  assert.strictEqual(state2.data.length, 0);
}
const streamOptions = {
  encoding: &#x27;utf8&#x27;,
  // Note:  objectMode to prevent write-combining
  objectMode: true,
};
const stream1 = new stream.PassThrough(streamOptions);
const stream2 = new stream.PassThrough(streamOptions);
const options = {
  compare,
  incremental: streamCompare.makeIncremental(assert.deepStrictEqual),
};
const promise = streamCompare(stream1, stream2, options);
stream1.write(&#x27;hello&#x27;);
stream1.end(&#x27; world&#x27;);
stream2.write(&#x27;hello&#x27;);
stream2.end(&#x27; world&#x27;);
return promise;</code></pre></dd>
            <dt>removes inconclusive events before compare</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.strictEqual(state1.events.length, 0);
  assert.strictEqual(state2.events.length, 0);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  compare,
  incremental: streamCompare.makeIncremental(
    assert.deepStrictEqual,
    assert.deepStrictEqual,
  ),
};
const promise = streamCompare(stream1, stream2, options);
stream1.emit(&#x27;close&#x27;);
stream1.end();
stream2.emit(&#x27;close&#x27;);
stream2.end();
return promise;</code></pre></dd>
            <dt>doesn&#x27;t return early due to incompleteness</dt>
            <dd><pre><code>// Note:  objectMode to prevent write-combining
const stream1 = new stream.PassThrough({ objectMode: true });
const stream2 = new stream.PassThrough({ objectMode: true });
const options = {
  incremental: streamCompare.makeIncremental(assert.deepStrictEqual),
};
let isDone = false;
const promise = streamCompare(stream1, stream2, options).then(() =&#x3E; {
  isDone = true;
});
stream1.write(&#x27;he&#x27;);
stream2.write(&#x27;hel&#x27;);
stream1.end(&#x27;llo&#x27;);
stream2.write(&#x27;l&#x27;);
setImmediate(() =&#x3E; {
  assert.strictEqual(isDone, false);
  stream2.end(&#x27;o&#x27;);
});
return promise;</code></pre></dd>
            <dt>returns early if streams differ before ending</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  incremental: streamCompare.makeIncremental(assert.deepStrictEqual),
};
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
);
stream1.write(&#x27;hello&#x27;);
stream2.write(&#x27;hella&#x27;);
return promise;</code></pre></dd>
            <dt>returns early if stream ends early</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  incremental: streamCompare.makeIncremental(assert.deepStrictEqual),
};
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
);
// stream1 writes more data than stream2 but doesn&#x27;t end
stream1.write(&#x27;hello&#x27;);
stream2.end(&#x27;hell&#x27;);
return promise;</code></pre></dd>
            <dt>returns early if stream ends empty</dt>
            <dd><pre><code>const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const options = {
  incremental: streamCompare.makeIncremental(assert.deepStrictEqual),
};
const promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  (err) =&#x3E; { assertInstanceOf(err, assert.AssertionError); },
);
// stream1 writes more data than stream2 but doesn&#x27;t end
stream1.write(&#x27;hello&#x27;);
stream2.end();
return promise;</code></pre></dd>
            <dt>compares buffered different-data streams as not equal</dt>
            <dd><pre><code>const incrementalVal = false;
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
stream1.end(&#x27;hello&#x27;);
stream2.end(&#x27;world&#x27;);
return new Promise((resolve, reject) =&#x3E; {
  process.nextTick(resolve);
}).then(() =&#x3E; {
  const options = {
    compare: function compare(state1, state2) {
      throw new Error(&#x27;compare shouldn\&#x27;t be called&#x27;);
    },
    incremental: function incremental(state1, state2) {
      return incrementalVal;
    },
  };
  return streamCompare(stream1, stream2, options);
}).then((result) =&#x3E; {
  assert.strictEqual(result, incrementalVal);
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Promise</h1>
      <dl>
        <section class="suite">
          <h1>#checkpoint()</h1>
          <dl>
            <dt>does a non-incremental comparison and resolves on result</dt>
            <dd><pre><code>let compareCalled = false;
const compareValue = false;
function compare(state1, state2) {
  if (compareCalled) {
    process.nextTick(() =&#x3E; {
      throw new Error(&#x27;compare called multiple times&#x27;);
    });
  }
  compareCalled = true;
  return compareValue;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
setImmediate(() =&#x3E; {
  assert.strictEqual(compareCalled, false);
  promise.checkpoint();
  assert.strictEqual(compareCalled, true);
});
return promise.then((value) =&#x3E; {
  assert.strictEqual(value, compareValue);
  stream1.end();
  stream2.end();
  // Delay to ensure compare is not called
  return new Promise((resolve, reject) =&#x3E; {
    setImmediate(resolve);
  });
});</code></pre></dd>
            <dt>does not resolve for compare non-result</dt>
            <dd><pre><code>let compareValue;
function compare(state1, state2) {
  return compareValue;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
let ended = false;
const promise2 = promise.then(() =&#x3E; {
  ended = true;
});
return new Promise((resolve, reject) =&#x3E; {
  setImmediate(() =&#x3E; {
    assert.strictEqual(ended, false);
    promise.checkpoint();
    setImmediate(() =&#x3E; {
      assert.strictEqual(ended, false);
      stream1.end();
      stream2.end();
      resolve(promise2);
    });
  });
});</code></pre></dd>
            <dt>can compare before reading</dt>
            <dd><pre><code>let compareCount = 0;
const compareValue = false;
function compare(state1, state2) {
  compareCount += 1;
  return compareValue;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
const testData = Buffer.from(&#x27;test&#x27;);
promise.checkpoint();
// Test that data written after end is not read by StreamComparison
stream1.write(testData);
stream2.write(testData);
return promise.then((value) =&#x3E; {
  assert.strictEqual(value, compareValue);
  return new Promise((resolve, reject) =&#x3E; {
    setImmediate(() =&#x3E; {
      assert.strictEqual(compareCount, 1);
      assert.deepStrictEqual(stream1.read(), testData);
      assert.deepStrictEqual(stream2.read(), testData);
      resolve();
    });
  });
});</code></pre></dd>
            <dt>does not compare after resolving</dt>
            <dd><pre><code>let ended = false;
function compare(state1, state2) {
  assert.strictEqual(ended, false);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
stream1.end();
stream2.end();
return promise.then((value) =&#x3E; {
  ended = true;
  promise.checkpoint();
});</code></pre></dd>
            <dt>can take the place of the final compare</dt>
            <dd><pre><code>let ended = false;
const compareValue = false;
function compare(state1, state2) {
  if (ended) {
    process.nextTick(() =&#x3E; {
      throw new Error(&#x27;compare called after end&#x27;);
    });
  }
  return compareValue;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
let endCount = 0;
function onEnd() {
  endCount += 1;
  if (endCount === 2) {
    promise.checkpoint();
  }
}
stream1.on(&#x27;end&#x27;, onEnd);
stream2.on(&#x27;end&#x27;, onEnd);
stream1.end();
stream2.end();
return promise.then((value) =&#x3E; {
  assert.strictEqual(value, compareValue);
  ended = true;
  // Delay to ensure compare is not called
  return new Promise((resolve, reject) =&#x3E; {
    setImmediate(resolve);
  });
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#end()</h1>
          <dl>
            <dt>does a non-incremental compare and ends on non-result</dt>
            <dd><pre><code>let compareValue;
function compare(state1, state2) {
  return compareValue;
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
promise.end();
return promise;</code></pre></dd>
            <dt>does not compare after resolving</dt>
            <dd><pre><code>let ended = false;
function compare(state1, state2) {
  assert.strictEqual(ended, false);
}
const stream1 = new stream.PassThrough();
const stream2 = new stream.PassThrough();
const promise = streamCompare(stream1, stream2, compare);
stream1.end();
stream2.end();
return promise.then((value) =&#x3E; {
  ended = true;
  promise.end();
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
