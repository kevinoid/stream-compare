<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Specifications in Mocha</title>
  <meta name="generator" content="Mocha &lt;https://mochajs.org/&gt;" />
  <meta name="license" content="MIT" />
  <meta name="copyright" content="&#169; 2016 Kevin Locke &lt;kevin@kevinlocke.name&gt;" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous" />
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/highlight.js/9.1.0/styles/github.min.css" />
  <style type="text/css">
section section {
  margin-left: 1em;
}
section section section section {
  margin-left: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <section class="suite">
      <h1>streamCompare</h1>
      <dl>
        <dt>propagates the value returned by compare</dt>
        <dd><pre><code>var compareValue = false;
function compare(state1, state2) {
  return compareValue;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare)
  .then(function(value) {
    assert.strictEqual(value, compareValue);
  });
stream1.end();
stream2.end();
return promise;</code></pre></dd>
        <dt>propagates the value thrown by compare</dt>
        <dd><pre><code>var compareErr = new Error('compare error');
function compare(state1, state2) {
  throw compareErr;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare).then(
  neverCalled,
  function(err) { assert.strictEqual(err, compareErr); }
);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
        <dt>propagates falsey value thrown by compare</dt>
        <dd><pre><code>var compareErr = false;
function compare(state1, state2) {
  throw compareErr;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare).then(
  neverCalled,
  function(err) { assert.strictEqual(err, compareErr); }
);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
        <dt>passes stream state information to compare</dt>
        <dd><pre><code>var data1 = new Buffer('hello');
var data2 = new Buffer('there');
function compare(state1, state2) {
  deepEqual(state1.data, data1);
  deepEqual(state1.ended, true);
  deepEqual(state1.events, [
    {name: 'close', args: []},
    {name: 'end', args: []}
  ]);
  deepEqual(state1.totalDataLen, data1.length);
  deepEqual(state2.data, data2);
  deepEqual(state2.ended, true);
  deepEqual(state2.events, [
    {name: 'end', args: []}
  ]);
  deepEqual(state2.totalDataLen, data2.length);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare);
var writeSize = 2;
stream1.write(data1.slice(0, writeSize));
stream1.emit('close');
stream1.end(data1.slice(writeSize));
stream2.write(data2.slice(0, 0));
stream2.end(data2);
return promise;</code></pre></dd>
        <dt>treats string stream data as strings</dt>
        <dd><pre><code>var data1 = 'hello';
var data2 = 'there';
function compare(state1, state2) {
  assert.strictEqual(state1.data, data1);
  assert.strictEqual(state2.data, data2);
}
var stream1 = new stream.PassThrough({encoding: 'utf8'});
var stream2 = new stream.PassThrough({encoding: 'utf8'});
var promise = streamCompare(stream1, stream2, compare);
var writeSize = 2;
stream1.write(data1.slice(0, writeSize));
stream1.end(data1.slice(writeSize));
stream2.write(data2.slice(0, 0));
stream2.end(data2);
return promise;</code></pre></dd>
        <dt>compares empty streams as equal</dt>
        <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
        <dt>compares empty and non-empty streams as not equal</dt>
        <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.end();
stream2.end('hello');
return promise;</code></pre></dd>
        <dt>compares non-empty and empty streams as not equal</dt>
        <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.end('hello');
stream2.end();
return promise;</code></pre></dd>
        <dt>compares same-data streams as equal</dt>
        <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual);
stream1.end('hello');
stream2.end('hello');
return promise;</code></pre></dd>
        <dt>compares different-data streams as not equal</dt>
        <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.end('hello');
stream2.end('world');
return promise;</code></pre></dd>
        <dt>compares buffered different-data streams as not equal</dt>
        <dd><pre><code>var compareVal = false;
function compare(state1, state2) {
  return compareVal;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
stream1.end('hello');
stream2.end('world');
return new Promise(function(resolve, reject) {
  process.nextTick(resolve);
}).then(function() {
  return streamCompare(stream1, stream2, compare);
}).then(function(result) {
  assert.strictEqual(result, compareVal);
});</code></pre></dd>
        <dt>compares same-data same-writes as equal</dt>
        <dd><pre><code>// Note:  objectMode to prevent write-combining
var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var promise = streamCompare(stream1, stream2, deepEqual);
stream1.write('hello');
stream1.end(' world');
stream2.write('hello');
stream2.end(' world');
return promise;</code></pre></dd>
        <dt>compares same-data different-writes as equal</dt>
        <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual);
stream1.end('hello world');
stream2.write('hello');
stream2.end(' world');
return promise;</code></pre></dd>
        <dt>compares different-writes to objectMode streams equal</dt>
        <dd><pre><code>var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var promise = streamCompare(stream1, stream2, deepEqual);
stream1.end('hello world');
stream2.write('hello');
stream2.end(' world');
return promise;</code></pre></dd>
        <dt>compares different-writes as non-equal in objectMode</dt>
        <dd><pre><code>var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var options = {
  compare: deepEqual,
  objectMode: true
};
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.end('hello world');
stream2.write('hello');
stream2.end(' world');
return promise;</code></pre></dd>
        <section class="suite">
          <h1>argument checking</h1>
          <dl>
            <dt>throws for invalid stream1</dt>
            <dd><pre><code>assert.throws(
  function() {
    streamCompare(true, stream2, deepEqual);
  },
  function(err) {
    return err instanceof TypeError &amp;&amp;
      /\bstream1\b/.test(err.message);
  }
);</code></pre></dd>
            <dt>throws for invalid stream2</dt>
            <dd><pre><code>assert.throws(
  function() {
    streamCompare(stream1, true, deepEqual);
  },
  function(err) {
    return err instanceof TypeError &amp;&amp;
      /\bstream2\b/.test(err.message);
  }
);</code></pre></dd>
            <dt>throws for no .read() method and readPolicy 'least'</dt>
            <dd><pre><code>assert.throws(
  function() { streamCompare(stream1, new EventEmitter(), deepEqual); },
  function(err) {
    return err instanceof TypeError &amp;&amp;
      /\bread\b/.test(err.message) &amp;&amp;
      /\bleast\b/.test(err.message);
  }
);</code></pre></dd>
            <dt>throws for missing optionsOrCompare</dt>
            <dd><pre><code>assert.throws(
  function() { streamCompare(stream1, stream2, null); },
  function(err) {
    return err instanceof TypeError &amp;&amp;
      /\boptions\.compare\b/.test(err.message);
  }
);</code></pre></dd>
            <dt>throws for invalid optionsOrCompare</dt>
            <dd><pre><code>assert.throws(
  function() { streamCompare(stream1, stream2, true); },
  function(err) {
    return err instanceof TypeError &amp;&amp;
      /\boptions\.compare\b|\boptionsOrCompare\b/.test(err.message);
  }
);</code></pre></dd>
            <dt>throws for invalid options.readPolicy</dt>
            <dd><pre><code>assert.throws(
  function() {
    var options = {
      compare: deepEqual,
      readPolicy: 'invalid'
    };
    streamCompare(stream1, stream2, options);
  },
  function(err) {
    return err instanceof RangeError &amp;&amp;
      /\boptions\.readPolicy\b/.test(err.message);
  }
);</code></pre></dd>
            <dt>for invalid options.endEvents</dt>
            <dd><pre><code>assert.throws(
  function() {
    var options = {
      compare: deepEqual
    };
    options[optionName] = true;  // None accepts true as valid
    streamCompare(stream1, stream2, options);
  },
  function(err) {
    var optionRE = new RegExp('\\boptions\\.' + optionName + '\\b');
    return err instanceof TypeError &amp;&amp;
      optionRE.test(err.message);
  }
);</code></pre></dd>
            <dt>for invalid options.events</dt>
            <dd><pre><code>assert.throws(
  function() {
    var options = {
      compare: deepEqual
    };
    options[optionName] = true;  // None accepts true as valid
    streamCompare(stream1, stream2, options);
  },
  function(err) {
    var optionRE = new RegExp('\\boptions\\.' + optionName + '\\b');
    return err instanceof TypeError &amp;&amp;
      optionRE.test(err.message);
  }
);</code></pre></dd>
            <dt>for invalid options.incremental</dt>
            <dd><pre><code>assert.throws(
  function() {
    var options = {
      compare: deepEqual
    };
    options[optionName] = true;  // None accepts true as valid
    streamCompare(stream1, stream2, options);
  },
  function(err) {
    var optionRE = new RegExp('\\boptions\\.' + optionName + '\\b');
    return err instanceof TypeError &amp;&amp;
      optionRE.test(err.message);
  }
);</code></pre></dd>
            <dt>for invalid options.readPolicy</dt>
            <dd><pre><code>assert.throws(
  function() {
    var options = {
      compare: deepEqual
    };
    options[optionName] = true;  // None accepts true as valid
    streamCompare(stream1, stream2, options);
  },
  function(err) {
    var optionRE = new RegExp('\\boptions\\.' + optionName + '\\b');
    return err instanceof TypeError &amp;&amp;
      optionRE.test(err.message);
  }
);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>abortOnError</h1>
          <dl>
            <dt>compares error events by default</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual);
stream1.emit('error', new Error('Test'));
stream2.emit('error', new Error('Test'));
return promise;</code></pre></dd>
            <dt>can abort on error events</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  abortOnError: true,
  compare: deepEqual
};
var errTest = new Error('Test');
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) {
    assert.strictEqual(err, errTest);
  }
);
stream1.emit('error', errTest);
return promise;</code></pre></dd>
            <dt>doesn't call incremental or compare on abort</dt>
            <dd><pre><code>function compare(state1, state2) {
  process.nextTick(function() {
    throw new Error('compare shouldn\'t be called');
  });
}
function incremental(state1, state2) {
  process.nextTick(function() {
    throw new Error('incremental shouldn\'t be called');
  });
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  abortOnError: true,
  compare: compare,
  incremental: incremental
};
var errTest = new Error('Test');
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) {
    assert.strictEqual(err, errTest);
  }
);
stream1.emit('error', errTest);
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>delay</h1>
          <dl>
            <dt>compares delayed end events if delayed more</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
// Since 0 is treated as 1, min is 1
var eventDelay = 1;
var options = {
  compare: deepEqual,
  delay: eventDelay + 1
};
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.end();
stream2.end();
setTimeout(function() {
  stream1.emit('end');
}, eventDelay);
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>endEvents</h1>
          <dl>
            <dt>can end on custom event</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: deepEqual,
  endEvents: ['test']
};
var promise = streamCompare(stream1, stream2, options);
var ended = false;
promise.then(function() {
  ended = true;
});
stream1.emit('test');
return new Promise(function(resolve, reject) {
  setImmediate(function() {
    assert.strictEqual(ended, false);
    stream2.emit('test');
    resolve(promise);
  });
});</code></pre></dd>
            <dt>can avoid ending on stream 'end'</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual);
var ended = false;
promise.then(function() {
  ended = true;
});
stream1.end();
stream2.end();
return new Promise(function(resolve, reject) {
  setImmediate(function() {
    assert.strictEqual(ended, false);
    resolve();
  });
});</code></pre></dd>
            <dt>abortOnError takes precedence for 'error' event</dt>
            <dd><pre><code>function compare(state1, state2) {
  process.nextTick(function() {
    throw new Error('compare shouldn\'t be called');
  });
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  abortOnError: true,
  compare: compare,
  endEvents: ['end', 'error']
};
var errTest = new Error('Test');
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) {
    assert.strictEqual(err, errTest);
  }
);
// Note:  .emit() rather than .end() to avoid delay
stream1.emit('end');
stream2.emit('error', errTest);
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>events</h1>
          <dl>
            <dt>compares Readable events by default</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual);
stream1.emit('close');
stream1.end();
stream2.emit('close');
stream2.end();
return promise;</code></pre></dd>
            <dt>can ignore all events</dt>
            <dd><pre><code>function compare(state1, state2) {
  deepEqual(state1.events, []);
  deepEqual(state2.events, []);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  events: []
};
var promise = streamCompare(stream1, stream2, options);
stream1.emit('close');
stream1.emit('error');
stream1.end();
stream2.emit('close');
stream2.emit('error');
stream2.end();
return promise;</code></pre></dd>
            <dt>ignores non-Readable events by default</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual);
stream1.end();
stream1.emit('finish');
stream2.end();
return promise;</code></pre></dd>
            <dt>can compare custom events</dt>
            <dd><pre><code>var eventValue = {};
function compare(state1, state2) {
  deepEqual(state1.events, [
    {name: 'test', args: [eventValue]}
  ]);
  deepEqual(state2.events, []);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  events: ['test']
};
var promise = streamCompare(stream1, stream2, options);
stream1.emit('test', eventValue);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>ignores multiple occurrances of event name</dt>
            <dd><pre><code>var eventValue = {};
function compare(state1, state2) {
  deepEqual(state1.events, [
    {name: 'test', args: [eventValue]}
  ]);
  deepEqual(state2.events, []);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  events: ['test', 'test']
};
var promise = streamCompare(stream1, stream2, options);
stream1.emit('test', eventValue);
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>compares different Readable events as different</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.emit('close');
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>compares different event counts as different</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.emit('close');
stream1.emit('close');
stream1.end();
stream2.emit('close');
stream2.end();
return promise;</code></pre></dd>
            <dt>compares multiple non-overlapping end events</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
// streamCompare may read from either stream first and the 'end' event
// does not fire until read() is called after EOF, so we emit directly
// for first stream.  Then streamCompare must read from the second.
stream1.emit('end');
process.nextTick(function() {
  stream1.emit('end');
  stream2.end();
});
return promise;</code></pre></dd>
            <dt>compares immediate overlapping end events</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.end();
stream2.end();
stream2.once('end', function() {
  process.nextTick(function() {
    stream1.emit('end');
  });
});
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>incremental</h1>
          <dl>
            <dt>has no effect if null is returned</dt>
            <dd><pre><code>function incremental(state1, state2) {
  return null;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: deepEqual,
  incremental: incremental
};
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.end('hello');
stream2.end('world');
return promise;</code></pre></dd>
            <dt>avoids compare if a non-null value is returned</dt>
            <dd><pre><code>var incrementalValue = false;
function compare(state1, state2) {
  throw new Error('compare shouldn\'t be called');
}
function incremental(state1, state2) {
  return incrementalValue;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  incremental: incremental
};
var promise = streamCompare(stream1, stream2, options)
  .then(function(value) {
    assert.strictEqual(value, incrementalValue);
  });
stream1.end('hello');
stream2.end('hello');
return promise;</code></pre></dd>
            <dt>avoids compare if a value is thrown</dt>
            <dd><pre><code>var incrementalErr = new Error('incremental error');
function compare(state1, state2) {
  throw new Error('compare shouldn\'t be called');
}
function incremental(state1, state2) {
  throw incrementalErr;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  incremental: incremental
};
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) { assert.strictEqual(err, incrementalErr); }
);
stream1.end('hello');
stream2.end('hello');
return promise;</code></pre></dd>
            <dt>causes early return if a value is thrown</dt>
            <dd><pre><code>var incrementalErr = new Error('incremental error');
function compare(state1, state2) {
  throw new Error('compare shouldn\'t be called');
}
function incremental(state1, state2) {
  throw incrementalErr;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  incremental: incremental
};
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) { assert.strictEqual(err, incrementalErr); }
);
stream1.end('hello');
// stream2 writes more than stream1 but does not end.
stream2.write('hello2');
return promise;</code></pre></dd>
            <dt>is used in place of compare, if not specified</dt>
            <dd><pre><code>var incrementalValue = false;
function incremental(state1, state2) {
  return state1.ended &amp;&amp; state2.ended ? incrementalValue : null;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  incremental: incremental
};
var promise = streamCompare(stream1, stream2, options)
  .then(function(value) {
    assert.strictEqual(value, incrementalValue);
  });
stream1.end('hello');
stream2.end('world');
return promise;</code></pre></dd>
            <dt>calls done once when conclusive on end</dt>
            <dd><pre><code>function compare(state1, state2) {
  throw new Error('compare shouldn\'t be called');
}
var incrementalValue = {};
function incremental(state1, state2) {
  return incrementalValue;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  incremental: incremental
};
var promise = streamCompare(stream1, stream2, options)
  .then(function(value) {
    assert.strictEqual(value, incrementalValue);
  });
stream1.end();
stream2.end();
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>objectMode</h1>
          <dl>
            <dt>errors on differing-type reads not in objectMode</dt>
            <dd><pre><code>// Streams are in objectMode, streamCompare is not
var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, TypeError); }
);
stream1.write('hello');
stream1.end(new Buffer(' world'));
stream2.end();
return promise;</code></pre></dd>
            <dt>errors on object reads not in objectMode</dt>
            <dd><pre><code>// Streams are in objectMode, streamCompare is not
var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var promise = streamCompare(stream1, stream2, deepEqual).then(
  neverCalled,
  function(err) { assertInstanceOf(err, TypeError); }
);
stream1.end({test: true});
stream2.end();
return promise;</code></pre></dd>
            <dt>supports object reads in objectMode</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var options = {
  compare: deepEqual,
  objectMode: true
};
var promise = streamCompare(stream1, stream2, options);
stream1.end({test: true});
stream2.end({test: true});
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>readPolicy</h1>
          <dl>
            <dt>doesn't call read() when 'flowing'</dt>
            <dd><pre><code>var isDone = false;
var isPaused = true;
function incremental(state1, state2) {
  assert.strictEqual(isPaused, false);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: deepEqual,
  readPolicy: 'flowing',
  incremental: incremental
};
var promise = streamCompare(stream1, stream1, options).then(function() {
  isDone = true;
});
stream1.pause();
stream1.write('hello');
stream2.pause();
stream2.write('hello');
// Delay to ensure we don't read/finish
setImmediate(function() {
  assert.strictEqual(isDone, false);
  isPaused = false;
  stream1.resume();
  stream2.resume();
  stream1.end();
  stream2.end();
});
return promise;</code></pre></dd>
            <dt>compares the same stream as equal when 'flowing'</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var options = {
  compare: deepEqual,
  readPolicy: 'flowing'
};
var promise = streamCompare(stream1, stream1, options);
stream1.end('hello');
return promise;</code></pre></dd>
            <dt>handles empty-Buffer 'read' events</dt>
            <dd><pre><code>var data1 = new Buffer('hello world');
var data2 = [new Buffer('hello'), new Buffer(0), new Buffer(' world')];
function compare(state1, state2) {
  deepEqual(state1.data, data1);
  deepEqual(state1.events, [
    {name: 'data', args: [data1]}
  ]);
  // Data properly recombined by flowing reads
  deepEqual(state2.data, Buffer.concat(data2));
  // Events record each 'data' event, even empty ones
  deepEqual(state2.events, [
    {name: 'data', args: [data2[0]]},
    {name: 'data', args: [data2[1]]},
    {name: 'data', args: [data2[2]]}
  ]);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  events: ['data'],
  readPolicy: 'flowing'
};
var promise = streamCompare(stream1, stream2, options);
stream1.end(data1);
stream2.write(data2[0]);
// stream.PassThrough suppresses empty writes.  Emit it ourselves.
stream2.emit('data', data2[1]);
stream2.end(data2[2]);
return promise;</code></pre></dd>
            <dt>handles empty-string 'read' events</dt>
            <dd><pre><code>var data1 = 'hello world';
var data2 = ['hello', '', ' world'];
function compare(state1, state2) {
  deepEqual(state1.data, data1);
  deepEqual(state1.events, [
    {name: 'data', args: [data1]}
  ]);
  // Data properly recombined by flowing reads
  deepEqual(state2.data, data2.join(''));
  // Events record each 'data' event, even empty ones
  deepEqual(state2.events, [
    {name: 'data', args: [data2[0]]},
    {name: 'data', args: [data2[1]]},
    {name: 'data', args: [data2[2]]}
  ]);
}
var stream1 = new stream.PassThrough({encoding: 'utf8'});
var stream2 = new stream.PassThrough({encoding: 'utf8'});
var options = {
  compare: compare,
  events: ['data'],
  readPolicy: 'flowing'
};
var promise = streamCompare(stream1, stream2, options);
stream1.end(data1);
stream2.write(data2[0]);
// stream.PassThrough suppresses empty writes.  Emit it ourselves.
stream2.emit('data', data2[1]);
stream2.end(data2[2]);
return promise;</code></pre></dd>
            <dt>doesn't read any data when 'none'</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.strictEqual(state1.data, undefined);
  assert.strictEqual(state2.data, undefined);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  readPolicy: 'none'
};
var promise = streamCompare(stream1, stream2, options);
// Since there are no 'data' listeners, must .resume() to get 'end'
stream1.resume();
stream2.resume();
stream1.end('hello');
stream2.end('world');
return promise;</code></pre></dd>
            <dt>can treat data as events only</dt>
            <dd><pre><code>var data1 = new Buffer('hello');
var data2 = new Buffer('world');
function compare(state1, state2) {
  assert.strictEqual(state1.data, undefined);
  assert.strictEqual(state2.data, undefined);
  deepEqual(state1.events, [
    {name: 'close', args: []},
    {name: 'data', args: [data1]},
    {name: 'end', args: []}
  ]);
  deepEqual(state2.events, [
    {name: 'data', args: [data2]},
    {name: 'close', args: []},
    {name: 'end', args: []}
  ]);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  events: ['close', 'data', 'end', 'error'],
  readPolicy: 'none'
};
var promise = streamCompare(stream1, stream2, options);
stream1.emit('close');
stream1.end(data1);
stream2.write(data2);
stream2.emit('close');
stream2.end();
return promise;</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>.makeIncremental()</h1>
          <dl>
            <dt>makes incremental from a Buffer comparison function</dt>
            <dd><pre><code>var data1 = [new Buffer('hello'), new Buffer('world')];
var data2 = [new Buffer('hello'), new Buffer('there')];
// Use of compareCount in this way is illustrative, but over-specified.
// Callers shouldn't depend on this exact behavior.
// If this test breaks, it may be rewritten in a less-strict way
var compareCount = 0;
var compareValue = false;
function compareData(incData1, incData2) {
  deepEqual(incData1, data1[compareCount]);
  deepEqual(incData2, data2[compareCount]);
  compareCount += 1;
  // null/undefined means &quot;continue comparing future data&quot;
  return bufferEqual(incData1, incData2) ? null : compareValue;
}
function compare(state1, state2) {
  throw new Error('compare shouldn\'t be called');
}
// Note:  objectMode to prevent write-combining
var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var options = {
  compare: compare,
  incremental: streamCompare.makeIncremental(compareData)
};
var promise = streamCompare(stream1, stream2, options)
  .then(function(value) {
    assert.strictEqual(value, compareValue);
  });
stream1.write(data1[0]);
stream2.write(data2[0]);
stream1.end(data1[1]);
stream2.end(data2[1]);
return promise;</code></pre></dd>
            <dt>makes incremental from an event comparison function</dt>
            <dd><pre><code>var compareValue = false;
function compareEvents(incEvents1, incEvents2) {
  assertInstanceOf(incEvents1, Array);
  assertInstanceOf(incEvents2, Array);
  try {
    assert.deepEqual(incEvents1, incEvents2);
    // null/undefined means &quot;continue comparing future data&quot;
    return null;
  } catch (err) {
    return compareValue;
  }
}
function compare(state1, state2) {
  throw new Error('compare shouldn\'t be called');
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  incremental: streamCompare.makeIncremental(null, compareEvents)
};
var promise = streamCompare(stream1, stream2, options)
  .then(function(value) {
    assert.strictEqual(value, compareValue);
  });
stream1.emit('close');
stream1.end();
stream2.end();
return promise;</code></pre></dd>
            <dt>removes inconclusive data before compare</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.strictEqual(state1.data.length, 0);
  assert.strictEqual(state2.data.length, 0);
}
// Note:  objectMode to prevent write-combining
var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var options = {
  compare: compare,
  incremental: streamCompare.makeIncremental(deepEqual)
};
var promise = streamCompare(stream1, stream2, options);
stream1.write('hello');
stream1.end(' world');
stream2.write('hello');
stream2.end(' world');
return promise;</code></pre></dd>
            <dt>removes inconclusive string data before compare</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.strictEqual(state1.data.length, 0);
  assert.strictEqual(state2.data.length, 0);
}
var streamOptions = {
  encoding: 'utf8',
  // Note:  objectMode to prevent write-combining
  objectMode: true
};
var stream1 = new stream.PassThrough(streamOptions);
var stream2 = new stream.PassThrough(streamOptions);
var options = {
  compare: compare,
  incremental: streamCompare.makeIncremental(deepEqual)
};
var promise = streamCompare(stream1, stream2, options);
stream1.write('hello');
stream1.end(' world');
stream2.write('hello');
stream2.end(' world');
return promise;</code></pre></dd>
            <dt>removes inconclusive events before compare</dt>
            <dd><pre><code>function compare(state1, state2) {
  assert.strictEqual(state1.events.length, 0);
  assert.strictEqual(state2.events.length, 0);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  compare: compare,
  incremental: streamCompare.makeIncremental(deepEqual, deepEqual)
};
var promise = streamCompare(stream1, stream2, options);
stream1.emit('close');
stream1.end();
stream2.emit('close');
stream2.end();
return promise;</code></pre></dd>
            <dt>doesn't return early due to incompleteness</dt>
            <dd><pre><code>// Note:  objectMode to prevent write-combining
var stream1 = new stream.PassThrough({objectMode: true});
var stream2 = new stream.PassThrough({objectMode: true});
var options = {
  incremental: streamCompare.makeIncremental(deepEqual)
};
var isDone = false;
var promise = streamCompare(stream1, stream2, options).then(function() {
  isDone = true;
});
stream1.write('he');
stream2.write('hel');
stream1.end('llo');
stream2.write('l');
setImmediate(function() {
  assert.strictEqual(isDone, false);
  stream2.end('o');
});
return promise;</code></pre></dd>
            <dt>returns early if streams differ before ending</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  incremental: streamCompare.makeIncremental(deepEqual)
};
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
stream1.write('hello');
stream2.write('hella');
return promise;</code></pre></dd>
            <dt>returns early if stream ends early</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  incremental: streamCompare.makeIncremental(deepEqual)
};
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
// stream1 writes more data than stream2 but doesn't end
stream1.write('hello');
stream2.end('hell');
return promise;</code></pre></dd>
            <dt>returns early if stream ends empty</dt>
            <dd><pre><code>var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var options = {
  incremental: streamCompare.makeIncremental(deepEqual)
};
var promise = streamCompare(stream1, stream2, options).then(
  neverCalled,
  function(err) { assertInstanceOf(err, assert.AssertionError); }
);
// stream1 writes more data than stream2 but doesn't end
stream1.write('hello');
stream2.end();
return promise;</code></pre></dd>
            <dt>compares buffered different-data streams as not equal</dt>
            <dd><pre><code>var incrementalVal = false;
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
stream1.end('hello');
stream2.end('world');
return new Promise(function(resolve, reject) {
  process.nextTick(resolve);
}).then(function() {
  var options = {
    compare: function compare(state1, state2) {
      throw new Error('compare shouldn\'t be called');
    },
    incremental: function incremental(state1, state2) {
      return incrementalVal;
    }
  };
  return streamCompare(stream1, stream2, options);
}).then(function(result) {
  assert.strictEqual(result, incrementalVal);
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Promise</h1>
      <dl>
        <section class="suite">
          <h1>#checkpoint()</h1>
          <dl>
            <dt>does a non-incremental comparison and resolves on result</dt>
            <dd><pre><code>var compareCalled = false;
var compareValue = false;
function compare(state1, state2) {
  if (compareCalled) {
    process.nextTick(function() {
      throw new Error('compare called multiple times');
    });
  }
  compareCalled = true;
  return compareValue;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare);
setImmediate(function() {
  assert.strictEqual(compareCalled, false);
  promise.checkpoint();
  assert.strictEqual(compareCalled, true);
});
return promise.then(function(value) {
  assert.strictEqual(value, compareValue);
  stream1.end();
  stream2.end();
  // Delay to ensure compare is not called
  return new Promise(function(resolve, reject) {
    setImmediate(resolve);
  });
});</code></pre></dd>
            <dt>does not resolve for compare non-result</dt>
            <dd><pre><code>var compareValue;
function compare(state1, state2) {
  return compareValue;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare);
var ended = false;
promise.then(function() {
  ended = true;
});
return new Promise(function(resolve, reject) {
  setImmediate(function() {
    assert.strictEqual(ended, false);
    promise.checkpoint();
    setImmediate(function() {
      assert.strictEqual(ended, false);
      stream1.end();
      stream2.end();
      resolve(promise);
    });
  });
});</code></pre></dd>
            <dt>can compare before reading</dt>
            <dd><pre><code>var compareCount = 0;
var compareValue = false;
function compare(state1, state2) {
  compareCount += 1;
  return compareValue;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare);
var testData = new Buffer('test');
promise.checkpoint();
// Test that data written after end is not read by StreamComparison
stream1.write(testData);
stream2.write(testData);
return promise.then(function(value) {
  assert.strictEqual(value, compareValue);
  return new Promise(function(resolve, reject) {
    setImmediate(function() {
      assert.strictEqual(compareCount, 1);
      deepEqual(stream1.read(), testData);
      deepEqual(stream2.read(), testData);
      resolve();
    });
  });
});</code></pre></dd>
            <dt>does not compare after resolving</dt>
            <dd><pre><code>var ended = false;
function compare(state1, state2) {
  assert.strictEqual(ended, false);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare);
stream1.end();
stream2.end();
return promise.then(function(value) {
  ended = true;
  promise.checkpoint();
});</code></pre></dd>
            <dt>can take the place of the final compare</dt>
            <dd><pre><code>var ended = false;
var compareValue = false;
function compare(state1, state2) {
  if (ended) {
    process.nextTick(function() {
      throw new Error('compare called after end');
    });
  }
  return compareValue;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare);
var endCount = 0;
function onEnd() {
  endCount += 1;
  if (endCount === 2) {
    promise.checkpoint();
  }
}
stream1.on('end', onEnd);
stream2.on('end', onEnd);
stream1.end();
stream2.end();
return promise.then(function(value) {
  assert.strictEqual(value, compareValue);
  ended = true;
  // Delay to ensure compare is not called
  return new Promise(function(resolve, reject) {
    setImmediate(resolve);
  });
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#end()</h1>
          <dl>
            <dt>does a non-incremental compare and ends on non-result</dt>
            <dd><pre><code>var compareValue;
function compare(state1, state2) {
  return compareValue;
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare);
promise.end();
return promise;</code></pre></dd>
            <dt>does not compare after resolving</dt>
            <dd><pre><code>var ended = false;
function compare(state1, state2) {
  assert.strictEqual(ended, false);
}
var stream1 = new stream.PassThrough();
var stream2 = new stream.PassThrough();
var promise = streamCompare(stream1, stream2, compare);
stream1.end();
stream2.end();
return promise.then(function(value) {
  ended = true;
  promise.end();
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
  </div><!-- .container -->

  <script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/2.2.1/jquery.min.js"></script>
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/highlight.js/9.1.0/highlight.min.js"></script>
  <script type="text/javascript">//<![CDATA[
'use strict';
// Adjust the nested heading level to match depth
$('section section h1').each(function() {
  var $this = $(this);
  var depth = Math.min($this.parents('section').length, 6);
  // http://stackoverflow.com/a/30059450/503410
  $this.wrapInner(document.createElement('h' + depth)).children().unwrap();
});

// Make the tests collapsible
var testNum = 0;
$('dt + dd')
  .addClass('collapse')
  .attr('role', 'tabpanel')
  .attr('aria-expanded', 'false')
  .each(function() {
    var $this = $(this);
    var $dt = $this.prev();

    ++testNum;
    var id = 'test' + testNum;
    var idDt = id + '-title';
    var idDd = id + '-desc';

    $dt.attr('id', idDt);
    $this.attr('id', idDd);

    $dt.wrapInner('<a role="button" data-toggle="collapse" href="#' + idDd +
        '" aria-expanded="false" aria-controls="' + idDd + '"></a>')
      .children()
      .collapse();
  });

// Enable syntax highlighting for the code (which is all JavaScript)
hljs.configure({languages: ['javascript']});
hljs.initHighlighting();
//]]></script>
</body>
</html>
